# -*- coding: utf-8 -*-
"""Campo Vetorial com manim.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bi6bI80dpZ1ikPzS9bE_7GWssFfSmhYH

#Instalação

##Base
"""

!sudo apt update
!sudo apt install libcairo2-dev ffmpeg \
    texlive texlive-latex-extra texlive-fonts-extra \
    texlive-latex-recommended texlive-science \
    tipa libpango1.0-dev
!pip install IPython --upgrade
!pip install manim
!pip install decorator
!pip install librosa

!apt update
!apt install -y libcairo2-dev libjpeg-dev libgif-dev python3.7-dev libffi-dev libssl-dev
!apt install -y ffmpeg sox

!apt-get install -y imagemagick
!sed -i '/PDF/s/none/read|write/' /etc/ImageMagick-6/policy.xml
!sed -i '/LABEL/s/none/read|write/' /etc/ImageMagick-6/policy.xml
!sed -i '/MVG/s/none/read|write/' /etc/ImageMagick-6/policy.xml
!sed -i '/MSL/s/none/read|write/' /etc/ImageMagick-6/policy.xml
!sed -i '/SHOW/s/none/read|write/' /etc/ImageMagick-6/policy.xml
!sed -i '/WIN/s/none/read|write/' /etc/ImageMagick-6/policy.xml
!sed -i '/PLT/s/none/read|write/' /etc/ImageMagick-6/policy.xml
!pip install JSAnimation
!apt install ffmpeg

!apt update
!apt install -y libcairo2-dev libjpeg-dev libgif-dev python3.7-dev libffi-dev libssl-dev
!apt install -y ffmpeg sox
!apt list --upgradable | awk -F/ '/deb/ && !/libgcc/{print $1}' | xargs sudo apt-get -y upgrade

"""##upgrades"""

!apt list --upgradable

!apt list --upgradable | awk -F/ '/deb/ && !/libgcc/{print $1}' | xargs sudo apt-get -y upgrade

!sudo apt-get install -f



"""##Manim version

###Teste
"""

from manim import *
import numpy as np
import matplotlib.pyplot as plt
from manim import *
from moviepy.editor import *

# Commented out IPython magic to ensure Python compatibility.
# %%manim -qm -v WARNING SquareToCircle
# 
# class SquareToCircle(Scene):
#    def construct(self):
#       square = Square()
#       circle = Circle()
#       circle.set_fill(PINK, opacity=0.5)
#       self.play(Create(square))
#       self.play(Transform(square, circle))
#       self.wait()

"""#Animation V2"""

!manim test.py Test

"""#Campo 1.

##V1.

##V2 Espiral est'avel
"""

from manim import *
from scipy.integrate import odeint

class StableSpiralVectorField(Scene):
    def construct(self):
        plane = NumberPlane()

        # Definindo o campo vetorial
        def vector_field_func(point):
            x, y, z = point
            dx = -y - (x+5)
            dy = x - (y+3)
            return np.array([dx, dy, 0])

        vector_field = VectorField(vector_field_func)

        # Adicionando o plano e o campo vetorial à cena
        self.add(plane, vector_field)

        # Adicionando um ponto de partida para a trajetória
        starting_point = [3, 0, 0]
        trajectory = self.get_trajectory(starting_point, vector_field_func)

        # Adicionando a trajetória à cena
        self.add(trajectory)

    def get_trajectory(self, starting_point, vector_field_func, t_max=10, dt=0.1):
        """
        Calcula a trajetória de uma partícula em um campo vetorial, dado um ponto de partida.
        """
        trajectory = ParametricFunction(
            lambda t: starting_point + odeint(vector_field_func, starting_point, np.arange(0, t, dt))[-1],
            t_min=0, t_max=t_max
        )
        return trajectory

"""#Campo 2

Definir a equação diferencial: Primeiro, precisamos definir a equação diferencial. Sabendo que o traço é a soma dos autovalores (λ1 + λ2) e o determinante é o produto dos autovalores (λ1 * λ2), podemos usar essas informações para encontrar os autovalores. No entanto, para uma equação diferencial 2D, não temos informações suficientes para definir completamente a equação diferencial apenas com o traço e o determinante. Precisamos de mais informações, como a forma da equação diferencial ou os autovetores.

Para uma matriz 2x2, os autovalores são dados pela fórmula:

λ = (Tr ± sqrt(Tr^2 - 4*Det)) / 2

onde Tr é o traço e Det é o determinante.  Substituindo esses valores na fórmula, podemos encontrar os autovalores.
"""

import math

# Definindo o traço e o determinante
trace = -5
determinant = 3

# Calculando os autovalores
lambda1 = (trace + math.sqrt(trace**2 - 4*determinant)) / 2
lambda2 = (trace - math.sqrt(trace**2 - 4*determinant)) / 2

print("Os autovalores são:", lambda1, lambda2)

"""Agora que temos os autovalores, podemos definir uma equação diferencial que tenha esses autovalores. Uma possibilidade é a seguinte equação diferencial:

dx/dt = λ1x
dy/dt = λ2y

Agora, vamos criar uma função Python que retorna o campo vetorial de uma equação diferencial baseada apenas no traço e no determinante:
"""

def get_vector_field(trace, determinant):
    # Calculando os autovalores
    lambda1 = (trace + math.sqrt(trace**2 - 4*determinant)) / 2
    lambda2 = (trace - math.sqrt(trace**2 - 4*determinant)) / 2

    # Definindo a função do campo vetorial
    def vector_field_func(point):
        x, y, z = point
        return np.array([lambda1*x, lambda2*y, 0])

    return vector_field_func

"""Agora, vamos classificar o ponto de equilíbrio. Para isso, podemos adicionar uma verificação de condição na função acima que verifica os autovalores e retorna o tipo de ponto de equilíbrio:

Para uma equação diferencial linear homogênea de segunda ordem com coeficientes constantes, a solução geral é da forma:

y(t) = c1 * e^(lambda1 * t) + c2 * e^(lambda2 * t)

onde c1 e c2 são constantes, e lambda1 e lambda2 são os autovalores. Podemos adicionar essa solução à nossa função existente:
"""

import cmath
import numpy as np

def get_vector_field_and_equilibrium_type(trace, determinant):
    # Calculando os autovalores
    lambda1 = (trace + cmath.sqrt(trace**2 - 4*determinant)) / 2
    lambda2 = (trace - cmath.sqrt(trace**2 - 4*determinant)) / 2

    # Classificando o ponto de equilíbrio
    if lambda1.real == lambda2.real:
        if lambda1.imag == 0:  # Autovalores reais
            if lambda1 == lambda2:  # Autovalores reais repetidos
                equilibrium_type = "node"
            else:  # Autovalores reais distintos
                if lambda1.real > 0:
                    equilibrium_type = "unstable node"
                else:
                    equilibrium_type = "stable node"
        else:  # Autovalores complexos
            if lambda1.real > 0:
                equilibrium_type = "unstable focus"
            elif lambda1.real < 0:
                equilibrium_type = "stable focus"
            else:
                equilibrium_type = "center"
    else:  # Autovalores reais com sinais opostos
        equilibrium_type = "saddle"

    # Definindo a função do campo vetorial
    def vector_field_func(point):
        x, y = point[:2]
        return np.array([
            x*lambda1.real - y*lambda1.imag,
            x*lambda2.real + y*lambda2.imag,
            0
        ])

    # Calculando a solução geral
    if lambda1.imag == 0 and lambda2.imag == 0:  # Autovalores reais
        if lambda1 == lambda2:  # Autovalores reais repetidos
            general_solution = "x(t) = (c1 + c2*t) * e^({}*t), y(t) = (c3 + c4*t) * e^({}*t)".format(lambda1.real, lambda2.real)
        else:  # Autovalores reais distintos
            general_solution = "x(t) = c1 * e^({}*t) + c2 * e^({}*t), y(t) = c3 * e^({}*t) + c4 * e^({}*t)".format(lambda1.real, lambda2.real, lambda1.real, lambda2.real)
    else:  # Autovalores complexos
        general_solution = "x(t) = e^({}*t) * (c1 * cos({}*t) + c2 * sin({}*t)), y(t) = e^({}*t) * (c3 * cos({}*t) + c4 * sin({}*t))".format(lambda1.real, lambda1.imag, lambda1.imag, lambda2.real, lambda2.imag, lambda2.imag)

    return vector_field_func, equilibrium_type, general_solution, lambda1, lambda2

get_vector_field_and_equilibrium_type(-4,4)

""" próximo passo é criar a cena & adicionar "pedras" à cena. No Manim, podemos fazer isso criando objetos Dot e adicionando-os à cena. Também queremos que as "pedras" se movam de acordo com o campo vetorial. Isso pode ser feito usando o método add_updater da classe Mobject, que permite adicionar uma função que atualiza a posição do objeto a cada frame. Aqui está como podemos fazer isso:


"""



from manim import *

class VectorFieldScene(Scene):
    def construct(self):
        # Definindo o traço e o determinante
        trace = -4
        determinant = -4

        # Obtendo a função do campo vetorial, o tipo de equilíbrio e a solução geral
        vector_field_func, equilibrium_type, general_solution, lambda1, lambda2 = get_vector_field_and_equilibrium_type(
            trace, determinant)

        # Criando o campo vetorial
        vector_field = VectorField(vector_field_func)

        # Adicionando o campo vetorial à cena
        self.add(vector_field)

        # Criando o texto para o tipo de equilíbrio e a solução geral
        equilibrium_text = Text("Equilibrium type: " + equilibrium_type)
        solution_text = Text("General solution: " + general_solution)

        # Posicionando o texto
        equilibrium_text.to_edge(UP)
        solution_text.next_to(equilibrium_text, DOWN)

        # Adicionando o texto à cena
        self.add(equilibrium_text, solution_text)

        # Adicionando "pedras" à cena
        for i in range(300):
            # Criando uma "pedra"
            stone = Dot()

            # Posicionando a "pedra" aleatoriamente
            stone.move_to(np.random.random(3) * 20 - 10)

            # Fazendo a "pedra" se mover de acordo com o campo vetorial
            stone.add_updater(lambda m, dt: m.shift(vector_field_func(m.get_center()) * dt))

            # Adicionando a "pedra" à cena
            self.add(stone)

        # Renderizando a cena por 5 segundos
        self.wait(10)

# Commented out IPython magic to ensure Python compatibility.
# %%manim -qm -v WARNING VectorFieldScene

"""##New Vector Field"""



from manim import ArrowVectorField, interpolate_color, BLUE, PURPLE
import numpy as np

class ColoredArrowVectorField(ArrowVectorField):
    def get_vector_color(self, vector):
        return interpolate_color(BLUE, PURPLE, np.linalg.norm(vector)/10)

def get_vector_field(trace, determinant):
    # Calculating the eigenvalues
    lambda1 = (trace + np.sqrt(trace**2 - 4*determinant)) / 2
    lambda2 = (trace - np.sqrt(trace**2 - 4*determinant)) / 2

    def vector_field_func(point):
        x, y = point[:2]
        return np.array([
            x*lambda1.real - y*lambda1.imag,
            x*lambda2.real + y*lambda2.imag,
            0
        ])

    # Creating the vector field
    vector_field = ArrowVectorField(vector_field_func)
    vector_field.set_color_by_gradient(BLUE, PURPLE)

    return vector_field, equilibrium_type, lambda1, lambda2

import cmath
import numpy as np

def get_vector_field_and_equilibrium_type(trace, determinant):
    # Calculando os autovalores
    lambda1 = (trace + cmath.sqrt(trace**2 - 4*determinant)) / 2
    lambda2 = (trace - cmath.sqrt(trace**2 - 4*determinant)) / 2

    # Classificando o ponto de equilíbrio
    if lambda1.real == lambda2.real:
        if lambda1.imag == 0:  # Autovalores reais
            if lambda1 == lambda2:  # Autovalores reais repetidos

                if lambda1.real > 0:
                    equilibrium_type = "unstable node"
                else:
                    equilibrium_type = "stable node"

            else:  # Autovalores reais distintos
                if lambda1.real > 0:
                    equilibrium_type = "unstable node"
                else:
                    equilibrium_type = "stable node"
        else:  # Autovalores complexos
            if lambda1.real > 0:
                equilibrium_type = "unstable focus"
            elif lambda1.real < 0:
                equilibrium_type = "stable focus"
            else:
                equilibrium_type = "center"
    else:  # Autovalores reais com sinais opostos
        equilibrium_type = "saddle"

    def vector_field_func(point):
        x, y = point[:2]
        return np.array([
            x*lambda1.real - y*lambda1.imag,
            x*lambda2.real + y*lambda2.imag,
            0
        ])

    # Creating the vector field
    vector_field = ColoredArrowVectorField(vector_field_func)

    # Calculando a solução geral
    if lambda1.imag == 0 and lambda2.imag == 0:  # Autovalores reais
        if lambda1 == lambda2:  # Autovalores reais repetidos
            general_solution = "x(t) = (c1 + c2*t) * e^({}*t), y(t) = (c3 + c4*t) * e^({}*t)".format(lambda1.real, lambda2.real)
        else:  # Autovalores reais distintos
            general_solution = "x(t) = c1 * e^({}*t) + c2 * e^({}*t), y(t) = c3 * e^({}*t) + c4 * e^({}*t)".format(lambda1.real, lambda2.real, lambda1.real, lambda2.real)
    else:  # Autovalores complexos
        general_solution = "x(t) = e^({}*t) * (c1 * cos({}*t) + c2 * sin({}*t)), y(t) = e^({}*t) * (c3 * cos({}*t) + c4 * sin({}*t))".format(lambda1.real, lambda1.imag, lambda1.imag, lambda2.real, lambda2.imag, lambda2.imag)

    return vector_field_func, equilibrium_type, general_solution, lambda1, lambda2
get_vector_field_and_equilibrium_type(4,4)

class VectorFieldScene(Scene):
    def construct(self):
        # Defining the trace and the determinant
        trace = 5
        determinant = 4

        # Getting the vector field and other information
        vector_field, equilibrium_type, general_solution, _, _ = get_vector_field_and_equilibrium_type(trace, determinant)

        # Adding the vector field to the scene
        self.add(vector_field)

        # Continue with the rest of your code...
        # Criando o texto para o tipo de equilíbrio e a solução geral
        equilibrium_text = Text("Equilibrium type: " + equilibrium_type)
        solution_text = Text("General solution: " + general_solution)

        # Posicionando o texto
        equilibrium_text.to_edge(UP)
        solution_text.next_to(equilibrium_text, DOWN)

        # Adicionando o texto à cena
        self.add(equilibrium_text, solution_text)

        # Adicionando "pedras" à cena
        for i in range(3):
            # Criando uma "pedra"
            stone = Dot()

            # Posicionando a "pedra" aleatoriamente
            stone.move_to(np.random.random(3) * 20 - 1)

            # Fazendo a "pedra" se mover de acordo com o campo vetorial
            stone.add_updater(lambda m, dt: m.shift(vector_field_func(m.get_center()) * dt))

            # Adicionando a "pedra" à cena
            self.add(stone)

        # Renderizando a cena por 5 segundos
        self.wait(2)

# Commented out IPython magic to ensure Python compatibility.
# %%manim -qm -v WARNING VectorFieldScene

import cmath
import numpy as np

def get_vector_field_and_equilibrium_type(trace, determinant):
    # Calculando os autovalores
    lambda1 = (trace + cmath.sqrt(trace**2 - 4*determinant)) / 2
    lambda2 = (trace - cmath.sqrt(trace**2 - 4*determinant)) / 2

    # Classificando o ponto de equilíbrio
    if lambda1.real == lambda2.real:
        if lambda1.imag == 0:  # Autovalores reais
            if lambda1 == lambda2:  # Autovalores reais repetidos
                if lambda1.real > 0:
                    equilibrium_type = "Nó instável, autovalores repetidos"
                else:
                    equilibrium_type = "Nó estável, autovalores repetidos"
            else:  # Autovalores reais distintos
                if lambda1.real > 0 and lambda2.real > 0:
                    equilibrium_type = "Nó instável, autovalores reais distintos"
                elif lambda1.real < 0 and lambda2.real < 0:
                    equilibrium_type = "Nó estável, autovalores reais distintos"
                else:
                    equilibrium_type = "Sela"
        else:  # Autovalores complexos
            if lambda1.real > 0:
                equilibrium_type = "Foco instável"
            elif lambda1.real < 0:
                equilibrium_type = "Foco estável"
            else:
                equilibrium_type = "Centro"
    elif lambda1.real * lambda2.real < 0:  # Autovalores reais com sinais opostos
        equilibrium_type = "Sela"
    else:
        print('Erro: não foi possível classificar o ponto de equilíbrio')
        return

    # Definindo a função do campo vetorial
    def vector_field_func(point):
        x, y = point[:2]
        if equilibrium_type in ["Foco instável", "Foco estável", "Centro"]:
            # Para foco e centro, o campo vetorial é uma rotação escalada pela parte real dos autovalores
            magnitude = np.sqrt(x**2 + y**2)
            phase = np.arctan2(y, x)
            if equilibrium_type == "Foco estável":
                scale = 1 - 1/magnitude if magnitude != 0 else 0
            elif equilibrium_type == "Foco instável":
                scale = 1 + 1/magnitude if magnitude != 0 else 0
            else:
                scale = 1
            return np.array([
                scale * magnitude * np.cos(phase + np.pi/2),
                scale * magnitude * np.sin(phase + np.pi/2),
                0
            ])
        else:
            # Para nó e sela, o campo vetorial é uma escala pelos autovalores
            return np.array([
                lambda1.real * x,
                lambda2.real * y,
                0
            ])

    # Calculando a solução geral
    if lambda1.imag == 0 and lambda2.imag == 0:  # Autovalores reais
        if lambda1 == lambda2:  # Autovalores reais repetidos
            general_solution = "x(t) = (c1 + c2*t) * e^({}*t), y(t) = (c3 + c4*t) * e^({}*t)".format(lambda1real, lambda2.real)
        else:  # Autovalores reais distintos
            general_solution = "x(t) = c1 * e^({}*t) + c2 * e^({}*t), y(t) = c3 * e^({}*t) + c4 * e^({}*t)".format(lambda1.real, lambda2.real, lambda1.real, lambda2.real)
    else:  # Autovalores complexos
        general_solution = "x(t) = e^({}*t) * (c1 * cos({}*t) + c2 * sin({}*t)), y(t) = e^({}*t) * (c3 * cos({}*t) + c4 * sin({}*t))".format(lambda1.real, lambda1.imag, lambda1.imag, lambda2.real, lambda2.imag, lambda2.imag)

    return vector_field_func, equilibrium_type, lambda1, lambda2, general_solution
get_vector_field_and_equilibrium_type(2,3)





import cmath
import numpy as np
from manim import *



class VectorFieldScene(Scene):
    def construct(self):
        # Defining the trace and the determinant
        trace = -5
        determinant = 3

        # Getting the vector field function and the equilibrium type
        vector_field_func, equilibrium_type, _, _, _ = get_vector_field_and_equilibrium_type(trace, determinant)


        # Creating the vector field
        vector_field = ArrowVectorField(vector_field_func)

        # Adding the vector field to the scene
        self.add(vector_field)

        # Creating the text for the equilibrium type
        equilibrium_text = Text("Equilibrium type: " + equilibrium_type)

        # Positioning the text
        equilibrium_text.to_edge(UP)

        # Adding the text to the scene
        self.add(equilibrium_text)

        # Adding "stones" to the scene
        for i in range(500):
            # Creating a "stone"
            stone = Dot()

            # Positioning the "stone" randomly
            stone.move_to(np.random.random(3) * 20 - 10)

            # Making the "stone" move according to the vector field
            stone.add_updater(lambda m, dt: m.shift(vector_field_func(m.get_center()) * dt))

            # Adding the "stone" to the scene
            self.add(stone)

        # Rendering the scene for x seconds
        self.wait(5)

# Commented out IPython magic to ensure Python compatibility.
# %%manim -qm -v WARNING VectorFieldScene

"""#V3

"""

def classify_equilibrium_point(lambda1, lambda2):
    # Classifying the equilibrium point
    if lambda1.real == lambda2.real:
        if lambda1.imag == 0:  # Real eigenvalues
            if lambda1 == lambda2:  # Repeated real eigenvalues
                equilibrium_type = "node"
            else:  # Distinct real eigenvalues
                if lambda1.real > 0:
                    equilibrium_type = "unstable node"
                else:
                    equilibrium_type = "stable node"
        else:  # Complex eigenvalues
            if lambda1.real > 0:
                equilibrium_type = "unstable focus"
            elif lambda1.real < 0:
                equilibrium_type = "stable focus"
            else:
                equilibrium_type = "center"
    else:  # Real eigenvalues with opposite signs
        equilibrium_type = "saddle"
    return equilibrium_type

def calculate_solutions(lambda1, lambda2):
    # Calculating the homogeneous and particular solutions
    if lambda1.imag == 0 and lambda2.imag == 0:  # Real eigenvalues
        if lambda1 == lambda2:  # Repeated real eigenvalues
            homogeneous_solution = "x(t) = (c1 + c2*t) * e^({}*t), y(t) = (c3 + c4*t) * e^({}*t)".format(lambda1.real, lambda2.real)
        else:  # Distinct real eigenvalues
            homogeneous_solution = "x(t) = c1 * e^({}*t) + c2 * e^({}*t), y(t) = c3 * e^({}*t) + c4 * e^({}*t)".format(lambda1.real, lambda2.real, lambda1.real, lambda2.real)
    else:  # Complex eigenvalues
        homogeneous_solution = "x(t) = e^({}*t) * (c1*cos({}*t) + c2*sin({}*t)), y(t) = e^({}*t) * (c3*cos({}*t) + c4*sin({}*t))".format(lambda1.real, lambda1.imag, lambda1.imag, lambda2.real, lambda2.imag, lambda2.imag)
    particular_solution =Peço desculpas pela resposta incompleta anterior. Aqui está a continuação:

```python
    particular_solution = "x(t) = c5, y(t) = c6"  # For linear systems, the particular solution can be a constant
    return homogeneous_solution, particular_solution

def create_vector_field(lambda1, lambda2):
    # Creating the vector field
    def vector_field_func(point):
        x, y = point[:2]
        dx = x - lambda1.real * x - lambda2.real * y
        dy = y - lambda1.imag * x - lambda2.imag * y
        return np.array([dx, dy, 0])

    vector_field = VectorField(vector_field_func)
    return vector_field

"""#Testes Tudo junto

O próximo passo é criar a interface do usuário. Para este exemplo, vamos usar a biblioteca Tkinter, que é uma biblioteca padrão do Python para a criação de interfaces gráficas. A interface do usuário terá campos de entrada para o traço e o determinante, e um botão para iniciar a animação. Aqui está um esboço de como isso pode ser feito:
"""

import tkinter as tk
from manim import *

# Função para iniciar a animação
def start_animation():
    # Obtendo o traço e o determinante da interface do usuário
    trace = float(trace_entry.get())
    determinant = float(determinant_entry.get())

    # Criando a cena
    scene = VectorFieldScene(trace, determinant)

    # Renderizando a cena
    scene.render()

# Criando a janela da interface do usuário
window = tk.Tk()

# Criando os campos de entrada para o traço e o determinante
trace_entry = tk.Entry(window)
determinant_entry = tk.Entry(window)

# Criando o botão para iniciar a animação
start_button = tk.Button(window, text="Start animation", command=start_animation)

# Adicionando os campos de entrada e o botão à janela
trace_entry.pack()
determinant_entry.pack()
start_button.pack()

# Iniciando o loop principal da interface do usuário
window.mainloop()